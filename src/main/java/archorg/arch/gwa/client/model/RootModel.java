package archorg.arch.gwa.client.model;

import it.celi.research.balrog.beacon.Beacon;
import it.celi.research.balrog.beacon.BeaconImpl;
import it.celi.research.balrog.beacon.BeaconReader;
import it.celi.research.balrog.beacon.BeaconWriter;
import it.celi.research.balrog.beacon.Change;
import it.celi.research.balrog.claudenda.Claudenda;
import it.celi.research.balrog.event.Observable;
import archorg.arch.gwa.client.ClaudendumBeacon;
import archorg.arch.gwa.client.Trigger;
import archorg.arch.gwa.client.serialization.URIStateManager;
import archorg.arch.gwa.client.serialization.HasSerializableState;
import archorg.arch.gwa.client.serialization.SerializableState;
import archorg.arch.gwa.client.serialization.beacon.BeaconOnlySerializableState;
import archorg.arch.gwa.client.serialization.beacon.SerializableHasSerializableStateBeacon;

public class RootModel implements HasSerializableState
{
  // output only, transient
  private BeaconImpl<String> message_impl = new BeaconImpl<String>(null);

  // input/output only, non-transient
  private BeaconImpl<Boolean> has_child_impl = new BeaconImpl<Boolean>(false);

  // output only, non-transient
  // this is really problematic because we want to guarantee that whenever this
  // is set we call clearSubscribers on the old ChildModel
  private ClaudendumBeacon<ChildModel> child_impl =
    new ClaudendumBeacon<ChildModel>();

  public BeaconWriter<? super String> getMessageBW()
  {
    return message_impl;
  }

  public BeaconReader<? extends String> getMessageBR()
  {
    return message_impl;
  }

  public Beacon<Boolean> getHasChildB()
  {
    return has_child_impl;
  }

  public BeaconReader<? extends ChildModel> getChildBR()
  {
    return child_impl;
  }

  public RootModel(Claudenda clau)
  {
    // triggers always before serialization, or else
    // the events that save the state (those generated by notable beacons) will
    // save the state as it is BEFORE the triggers resolve
    has_child_impl.subscribe(new Trigger<Boolean>()
    {
      @Override
      public void
          onTrigger(Observable<? extends Change<? extends Boolean>> observable,
              Change<? extends Boolean> message)
      {
        if (message.newEqualsOld())
          return;
        if (message.getNew())
        {
          Claudenda child_impl_claudenda =
            new Claudenda(RootModel.this.getClass());
          child_impl.setIfNotEqual(new ChildModel(child_impl_claudenda,
            message_impl));
          child_impl.setClaudenda(child_impl_claudenda);
        } else
        {
          child_impl.get().clearSubscribers();
          child_impl.setIfNotEqual(null);
        }
      }
    });
    // serialization
    serializablestate = new BeaconOnlySerializableState(clau)
    {
      @Override
      public void afterLoading()
      {
        if (child_impl.isNotNull())
          has_child_impl.setIfNotEqual(true);
        else
          has_child_impl.setIfNotEqual(false);
      }
    };
    serializablestate.addTransientBeacon(has_child_impl);
    serializablestate
      .addNonTransientBeacon(new SerializableHasSerializableStateBeacon<ChildModel>(
        "child", child_impl)
      {
        // our problem here is that we can't just create and destroy ChildModels
        // without managing the claudenda
        @Override
        public ChildModel create(boolean dryrun)
        {
          Claudenda child_impl_claudenda =
            new Claudenda(RootModel.this.getClass());
          ChildModel childModel =
            new ChildModel(child_impl_claudenda, message_impl);
          child_impl.setClaudenda(child_impl_claudenda);
          return childModel;
        }
      });
    serializablestate.addTransientBeacon(message_impl);
    // tells the hardlink manager to store the state whenever this observable
    // broadcasts an event
    URIStateManager.saveOnEvent(has_child_impl);
  }

  @Override
  public SerializableState getSerializableState()
  {
    return serializablestate;
  }

  private BeaconOnlySerializableState serializablestate;
}
